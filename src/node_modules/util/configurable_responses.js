// Copyright Titanium I.T. LLC.
import * as ensure from "util/ensure.js";
import * as type from "util/type.js";

/**
 * A helper class for implementing the Configurable Responses pattern.
 * https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#configurable-responses
 */
export class ConfigurableResponses {

	/**
	 * Factory method. Create a list of responses (by providing an array)
	 * or a single repeating response (by providing any other type).
	 * @param responses The responses to provide. If an array is provided,
	 * then each call to next() will return the next response in the array,
	 * and will throw an exception when it runs out. If anything else is
	 * provided, that response will be returned on every call to next().
	 * @param name Optional; used in error messages.
	 * @returns {ConfigurableResponses} the instance
	 */
	static create(responses, name) {
		ensure.signature(arguments, [ type.ANY, [ undefined, String ]]);

		return new ConfigurableResponses(responses, name);
	}

	/**
	 * Convert all properties in an object into ConfigurableResponses instances.
	 * For example, { a: 1 } becomes { a: ConfigurableResponses.create(1) }.
	 * @param responseObject The object to convert.
	 * @param name Optional; used in error messages.
	 * @returns {{[p: string]: ConfigurableResponses}} a new mapped object
	 */
	static mapObject(responseObject, name) {
		ensure.signature(arguments, [ Object, [ undefined, String ]]);

		const entries = Object.entries(responseObject);
		const translatedEntries = entries.map(([ key, value ]) => {
			const translatedName = name === undefined ? undefined : `${name}: ${key}`;
			return [ key, ConfigurableResponses.create(value, translatedName )];
		});
		return Object.fromEntries(translatedEntries);
	}

	/** @deprecated Use the factory method instead. */
	constructor(responses, name) {
		ensure.signature(arguments, [ type.ANY, [ undefined, String ]]);

		this._description = name === undefined ? "" : ` in ${name}` ;
		this._responses = Array.isArray(responses)
			? [ ...responses ]
			: responses;
	}

	/**
	 * Get next configured response. If create() was called with an array, it returns
	 * the next item in the array, and throws an error when no responses remain.
	 * If create() wasn't called with an array, it returns that response every time
	 * it's called.
	 * @returns {*} the next response
	 */
	next() {
		ensure.signature(arguments, []);

		const response = Array.isArray(this._responses)
			? this._responses.shift()
			: this._responses;
		if (response === undefined) throw new Error(`No more responses configured${this._description}`);

		return response;
	}

}