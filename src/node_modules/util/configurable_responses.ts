// Copyright Titanium I.T. LLC.

type Responses<T> = T | T[];

/**
 * A helper class for implementing the Configurable Responses pattern.
 * https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#configurable-responses
 */
export class ConfigurableResponses<T> {

	private readonly _description: string;
	private readonly _responses: Responses<T>;

	/**
	 * Factory method. Create a list of responses (by providing an array)
	 * or a single repeating response (by providing any other type).
	 * @param responses The responses to provide. If an array is provided,
	 * then each call to next() will return the next response in the array,
	 * and will throw an exception when it runs out. If anything else is
	 * provided, that response will be returned on every call to next().
	 * @param name Optional; used in error messages.
	 * @returns {ConfigurableResponses} the instance
	 */
	static create<T>(responses: Responses<T>, name?: string): ConfigurableResponses<T> {
		return new ConfigurableResponses(responses, name);
	}

	/**
	 * Convert all properties in an object into ConfigurableResponses instances.
	 * For example, { a: 1 } becomes { a: ConfigurableResponses.create(1) }.
	 * @param responseObject The object to convert.
	 * @param name Optional; used in error messages.
	 * @returns {{[p: string]: ConfigurableResponses}} a new mapped object
	 */
	static mapObject<K extends string | number | symbol, T>(
		responseObject: Record<K, Responses<T>>,
		name?: string,
	): Record<K, ConfigurableResponses<T>> {
		const entries = Object.entries(responseObject);
		const translatedEntries = entries.map(([ key, value ]) => {
			const translatedName = name === undefined ? undefined : `${name}: ${key}`;
			return [ key, ConfigurableResponses.create(value, translatedName )];
		});
		return Object.fromEntries(translatedEntries);
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(responses: Responses<T>, name?: string) {
		this._description = name === undefined ? "" : ` in ${name}` ;
		this._responses = Array.isArray(responses)
			? [ ...responses ]
			: responses;
	}

	/**
	 * Get next configured response. If create() was called with an array, it returns
	 * the next item in the array, and throws an error when no responses remain.
	 * If create() wasn't called with an array, it returns that response every time
	 * it's called.
	 * @returns {*} the next response
	 */
	next(): T {
		const response = Array.isArray(this._responses)
			? this._responses.shift()
			: this._responses;
		if (response === undefined) throw new Error(`No more responses configured${this._description}`);

		return response;
	}

}