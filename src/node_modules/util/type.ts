// Copyright (c) 2013-2016 Titanium I.T. LLC. All rights reserved. For license, see "README" or "LICENSE" file.

/**
 * Any type except undefined, null, or NaN.
 */
export const ANY_VALID = [ Boolean, String, Number, Function, Array, Object ];

/**
 * Any type.
 */
export const ANY = [ ...ANY_VALID, undefined, null, NaN ];

export interface TypeCheckOptions {
	name?: string;
	allowExtraKeys?: boolean;
}

interface InternalOptions extends TypeCheckOptions {
	articles?: boolean;
	atLeast?: boolean | undefined;
}

/**
 * Runtime type checker. Compares the type of a variable to a set of expected types and either returns 'null'
 * or a string explaining why it doesn't match.
 * @param variable the variable
 * @param expectedTypes The expected type. Use JavaScript's class names: String, Number, Array, etc. You can
 * also use 'undefined', 'null', and 'NaN'. For instances, use the name of your class or constructor
 * function (e.g., 'MyClass'). For objects with specific properties, provide an object, and specify
 * the type(s) of each property (e.g., { a: Number, b: [ undefined, String ]}). For parameters
 * that allow multiple types, provide an array containing each type. For optional parameters, provide
 * an array and include 'undefined' as one of the options (e.g., [ undefined, String ].
 * @param name the name of the variable (used in error messages)
 * @param [options] options
 * @param [options.name] the name of the variable (used in error messages)
 * @param [options.allowExtraKeys] allow unspecified properties when comparing to an object expectation (e.g.,
 * if expectedTypes is { a: Number }, don't complain if comparing to { a: 1, b: 2 })
 * @returns {string|null} a string explaining why the variable doesn't match the type, or 'null' if it does match
 */
export function check(variable: any, expectedTypes: any[] | any, options: TypeCheckOptions = {}): string | null {
	const argType = getType(variable);
	if (!Array.isArray(expectedTypes)) expectedTypes = [ expectedTypes ];
	options.name = options.name || "argument";

	for (let i = 0; i < expectedTypes.length; i++) {
		if (oneTypeMatches(variable, argType, expectedTypes[i])) {
			if (isStructComparison(argType, expectedTypes[i])) return checkStruct(variable, expectedTypes[i], options);
			else return null;
		}
	}
	return describeError(variable, argType, expectedTypes, options.name, options.allowExtraKeys);


	function oneTypeMatches(arg: any, argType: any, expectedType: any): boolean {
		if (argType === Object) return checkObject(arg, expectedType);
		else if (Number.isNaN(argType)) return Number.isNaN(expectedType);
		else return argType === expectedType;

		function checkObject(arg: object, type: any): boolean {
			if (type === null) return false;
			else if (typeof type === "function") return arg instanceof type;
			else if (typeof type === "object") return typeof arg === "object";
			else return false;
		}
	}

	function isStructComparison(argType: any, type: any): boolean {
		return argType === Object && typeof type === "object";
	}

	function checkStruct(arg: any, type: any, options: InternalOptions): string | null {
		if (typeof type !== "object") throw new Error("unrecognized type: " + type);

		const unmatched = Object.assign({}, arg);
		const keys = Object.getOwnPropertyNames(type);
		for (let i = 0; i < keys.length; i++) {
			const newOptions = Object.assign({}, options);
			newOptions.name = options.name + "." + keys[i];
			const checkResult = check(arg[keys[i]!], type[keys[i]!], newOptions);
			if (checkResult !== null) return checkResult;
			delete unmatched[keys[i]!];
		}
		if (!options.allowExtraKeys) {
			const unmatchedKeys = Object.keys(unmatched);
			const s = unmatchedKeys.length > 1 ? "s" : "";
			if (unmatchedKeys.length > 0) {
				let error = `${options.name} had unexpected parameter${s}: ${unmatchedKeys.join(", ")}`;
				if (!isStruct(arg)) {
					error = `${options.name} should probably be an anonymous object, but it was ` +
						`${describeInstance(arg, { articles: true })} (${error}). ` +
						`Did you forget to put it in curly braces?`;
				}
				return error;
			}
		}

		return null;
	}

	function describeError(arg: any, argType: any, type: any, name: string, allowExtraKeys?: boolean): string {
		const options = { articles: true, atLeast: allowExtraKeys };
		if (argType === Object && !isStruct(arg)) argType = arg;
		return name + " must be " + describe(type, options) + ", but it was " + describe(argType, options);
	}

}


/** Only for use by tests. (Use check() instead.) */
export function describe(type: any[] | any, options: InternalOptions = {}): string {
	if (!Array.isArray(type)) type = [ type ];

	const descriptions = type.map(function(oneType: any) {
		return describeOneType(oneType);
	});
	if (descriptions.length <= 2) {
		return descriptions.join(" or ");
	}
	else {
		const allButLast = descriptions.slice(0, -1);
		const last = descriptions[descriptions.length - 1];
		return allButLast.join(", ") + ", or " + last;    // dat Oxford comma
	}

	function describeOneType(type: any): string {
		switch(type) {
			case Boolean: return options.articles ? "a boolean" : "boolean";
			case String: return options.articles ? "a string" : "string";
			case Number: return options.articles ? "a number" : "number";
			case Function: return options.articles ? "a function" : "function";
			case Array: return options.articles ? "an array" : "array";
			case undefined: return "undefined";
			case null: return "null";

			default:
				if (Number.isNaN(type)) return "NaN";
				else if (typeof type === "function") return describeConstructor(type, options);
				else if (typeof type === "object") {
					if (isStruct(type)) return describeStruct(type, options);
					else return describeInstance(type, options);
				}
				else throw new Error("unrecognized type: " + type);
		}
	}

	function describeConstructor(type: any, options: InternalOptions) {
		const articles = options.articles;

		if (type === Object) return articles ? "an object" : "object";
		else if (type === RegExp) return articles ? "a regular expression" : "regular expression";

		let name = type.name;
		if (name) {
			if (articles) name = "a " + name;
		}
		else {
			name = articles ? "an <anon>" : "<anon>";
		}
		return name + " instance";
	}

	function describeStruct(type: any, options: InternalOptions) {
		const properties = Object.getOwnPropertyNames(type).map(function(key) {
			return key + ": <" + describe(type[key]) + ">";
		});

		const objectDesc = options.articles ? "an object" : "object";
		if (properties.length === 0) {
			return objectDesc;
		}

		const atLeast = options.atLeast ? "at least " : "";
		return objectDesc + ` containing ${atLeast}{ ${properties.join(", ")} }`;
	}

}

function describeInstance(type: any, options: InternalOptions) {
	const prototypeConstructor = Object.getPrototypeOf(type).constructor;
	const article = options.articles;
	let name = (article ? "a " : "") + prototypeConstructor.name;
	if (!prototypeConstructor.name) name = (article ? "an " : "") + "<anon>";

	return name + " instance";
}

function getType(variable: any): any {
	if (variable === null) return null;
	if (Array.isArray(variable)) return Array;
	if (Number.isNaN(variable)) return NaN;

	switch (typeof variable) {
		case "boolean": return Boolean;
		case "string": return String;
		case "number": return Number;
		case "function": return Function;
		case "object": return Object;
		case "undefined": return undefined;

		default:
			throw new Error("Unreachable code executed. Unknown typeof value: " + typeof variable);
	}
}

function isStruct(type: any): boolean {
	const prototype = Object.getPrototypeOf(type);
	return (!prototype || prototype.constructor === Object);
}
