// Copyright Titanium I.T. LLC.
import http from "node:http";
import childProcess from "node:child_process";
import { ChildProcess } from "child_process";

/**
 * Perform an HTTP request in a way that's convenient for tests. Deletes certain headers tests don't care about.
 * @param port localhost port
 * @param url path
 * @param method GET, POST, etc.
 * @param headers optional; headers to send
 * @param body optional; body to send
 * @returns { status, headers, body } status, headers, and body returned by server
 */
export async function requestAsync({
	port,
	url,
	method,
	headers,
	body = []
}: {
	port: number | string,
	url?: string,
	method?: string,
	headers: Record<string, string>,
	body?: string[],
}): Promise<{
	status: number | undefined,
	headers: Record<string, string | string[] | undefined>,
	body: string,
}> {
	return await new Promise((resolve, reject) => {
		if (method === undefined && body.length !== 0) method = "POST";

		const request = http.request({ port, path: url, method, headers });
		body.forEach((chunk) => request.write(chunk));
		request.end();

		request.on("response", (response) => {
			let body = "";
			response.on("data", (chunk) => {
				body += chunk;
			});
			response.on("error", (err) => reject(err));
			response.on("end", () => {
				const headers = response.headers;
				delete headers.connection;
				delete headers["content-length"];
				delete headers.date;

				resolve({
					status: response.statusCode,
					headers: response.headers,
					body,
				});
			});
		});
	});
}

/**
 * Run specified module in a separate process.
 * @param absolutePath path to module (relative to working directory)
 * @param args optional; process arguments (default none)
 * @param failOnStderr optional; if true, throws an error if anything is written to stderr (default true)
 * @returns { stdout, stderr } data written to stdout and stderr
 */
export function runModuleAsync(
	absolutePath: string,
	{ args = [], failOnStderr = true }: { args?: string[], failOnStderr?: boolean },
): Promise<{
	stdout: string,
	stderr: string,
}> {
	return new Promise((resolve, reject) => {
		const child = forkModule(absolutePath, { args });

		let stdout = "";
		let stderr = "";
		child.stdout!.on("data", (data) => {
			stdout += data;
		});
		child.stderr!.on("data", (data) => {
			stderr += data;
		});

		child.on("exit", (code) => {
			if (code !== 0 || (failOnStderr && stderr !== "")) {
				return reject(new Error(`Runner failed.\nstdout: ${stdout}\nstderr: ${stderr}`));
			}
			else {
				return resolve({ stdout, stderr });
			}
		});
	});
}

/**
 * Runs a Node.js module in a separate process.
 * @param absolutePath path to module
 * @param args optional; process arguments (default none)
 * @returns { stdout, stderr } data written to stdout and stderr
 */
export function forkModule(
	absolutePath: string,
	{ args = [] }: { args?: string[] } = {},
): ChildProcess {
	return childProcess.fork(absolutePath, args, { stdio: "pipe" });
}

/**
 * Resolves a promise and ignores any errors it throws.
 * @param promise the promise to ignore
 */
export async function ignorePromiseErrorAsync(promise: Promise<any>): Promise<void> {
	try {
		await promise;
	}
	catch (err) {
	}
}