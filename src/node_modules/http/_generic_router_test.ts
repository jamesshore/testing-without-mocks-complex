// Copyright Titanium I.T. LLC.
import assert from "util/assert.js";
import { Controller, GenericRouter, GenericRouterRequests, Routes } from "http/generic_router.js";
import { HttpServerRequest } from "http/http_server_request.js";
import { Log, LogData } from "infrastructure/log.js";
import { HttpServerResponse } from "http/http_server_response.js";
import { OutputTracker } from "util/output_listener.js";

describe("Generic Router", () => {

	describe("happy paths", () => {

		it("converts an HTTP request into a function call and returns the result", async () => {
			const routes = {
				"/": ExampleController.create(),
			};

			const { response: getResponse } = await routeAsync({ routes, method: "get", url: "/" });
			const { response: postResponse } = await routeAsync({ routes, method: "post", url: "/" });

			assert.equal(getResponse.method, "get");
			assert.equal(postResponse.method, "post");
		});

		it("passes request to route", async () => {
			const { response } = await routeAsync({ url: "/", method: "get" });
			assert.deepEqual(response.request, HttpServerRequest.createNull({ url: "/", method: "get" }));
		});

		it("passes optional arbitrary config object through to route", async () => {
			const context = { myContextObject: true };

			const { response } = await routeAsync({ url: "/", context });
			assert.equal(response.context, context);
		});

		it("supports multiple paths", async () => {
			const routes = {
				"/one": ExampleController.create("one"),
				"/two/is/a/deep/path": ExampleController.create("two"),
			};

			const { response: oneResponse } = await routeAsync({ routes, url: "/one" });
			const { response: twoResponse } = await routeAsync({ routes, url: "/two/is/a/deep/path" });

			assert.equal(oneResponse.name, "one");
			assert.equal(twoResponse.name, "two");
		});

		it("ignores query strings and fragments", async () => {
			const routes = {
				"/endpoint": ExampleController.create("my_controller"),
			};

			const { response } = await routeAsync({ routes, url: "/endpoint?query=something#fragment" });
			assert.equal(response.name, "my_controller");
		});

	});


	describe("logging", () => {

		it("logs requests", async () => {
			const { logOutput } = await routeAsync({ method: "get", url: "/endpoint" });

			assert.deepEqual(logOutput.data, [{
				alert: "info",
				message: "request",
				method: "get",
				path: "/endpoint",
			}]);
		});

		it("doesn't log queries or fragments (for security)", async () => {
			const { logOutput } = await routeAsync({ routes: "/endpoint", url: "/endpoint?with_query#and_fragment" });
			assert.deepEqual(logOutput.data[0]?.path, "/endpoint");
		});

	});


	describe("tracking", () => {

		it("tracks requests", async () => {
			const { requests } = await routeAsync({ method: "get", url: "/endpoint" });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

		it("includes context object", async () => {
			const context = { myContext: true };
			const { requests } = await routeAsync({ method: "get", url: "/endpoint", context });

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: { myContext: true },
			}]);

		});

		it("normalizes method case", async () => {
			const { requests } = await routeAsync({ method: "GET", url: "/endpoint" });
			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

		it("ignores query strings and fragments", async () => {
			const { requests } = await routeAsync({
				routes: "/endpoint",
				method: "get",
				url: "/endpoint?with_query#and_fragment"
			});

			assert.deepEqual(requests.data, [{
				method: "get",
				path: "/endpoint",
				context: undefined,
			}]);
		});

	});


	describe("failure paths", () => {

		it("calls error function when path not found", async () => {
			function errorFnAsync(status: number, errorMessage: string, request: HttpServerRequest) {
				return { status, errorMessage, request };
			}
			const { response } = await routeAsync({ routes: [], url: "/no-such-path", method: "get", errorFnAsync });

			assert.deepEqual(response, {
				status: 404,
				errorMessage: "not found",
				request: HttpServerRequest.createNull({ url: "/no-such-path", method: "get" }),
			});
		});

		it("calls error function when method not defined", async () => {
			function errorFnAsync(status: number, errorMessage: string, request: HttpServerRequest) {
				return { status, errorMessage, request };
			}

			const { response } = await routeAsync({ method: "put", url: "/endpoint", errorFnAsync });
			assert.deepEqual(response, {
				status: 405,
				errorMessage: "method not allowed",
				request: HttpServerRequest.createNull({ url: "/endpoint", method: "put" }),
			});
		});

	});

});

async function routeAsync<C>({
	errorFnAsync = fallbackErrorHandler,
	context = undefined,
	method = "GET",
	url = "/irrelevant_url",
	routes = url,
}: {
	errorFnAsync?: (status: number, errorMessage: string, request: HttpServerRequest) => any,
	context?: any,
	method?: string,
	url?: string,
	routes?: string | string[] | Routes<C>,
} = {}): Promise<{
	response: any,
	requests: OutputTracker<GenericRouterRequests<C>>,
	logOutput: OutputTracker<LogData>,
}> {
	const log = Log.createNull();
	const logOutput = log.trackOutput();

	const router = new GenericRouter(errorFnAsync, normalizeRoutes(routes));
	const requests = router.trackRequests();

	const request = HttpServerRequest.createNull({ method, url });
	const response = await router.routeAsync(request, log, context);

	return { response, requests, logOutput };
}

function normalizeRoutes<C>(routes: string | string[] | Routes<C>): Routes<C> {
	if (typeof routes === "string") {
		return { [routes]: ExampleController.create() };
	}
	else if (Array.isArray(routes)) {
		return Object.fromEntries(routes.map(path => [ path, ExampleController.create() ]));
	}
	else {
		return routes;
	}
}

function fallbackErrorHandler(status: number, message: string, request: HttpServerRequest): never {
	throw new Error(`fallback error handler called: ${JSON.stringify({ status, message, request })}`);
}


class ExampleController<C> implements Controller<C> {
	static create<C>(controllerName: string = "irrelevant_controller_name"): ExampleController<C> {
		return new ExampleController(controllerName);
	}

	constructor(private readonly _name: string) {
	}

	// TODO: should router return any? Or just HttpResponse?
	async getAsync(request: HttpServerRequest, context?: any): Promise<HttpServerResponse> {
		// Okay, this is obviously NOT an HttpResponse. But our tests don't actually care what type
		// is returned, so we'll call it an HttpResponse to make the typechecker happy.
		return { method: "get", request, context, name: this._name } as unknown as HttpServerResponse;
	}

	async postAsync(request: HttpServerRequest, context?: any): Promise<HttpServerResponse> {
		// same shenanigans as getAsync()
		return { method: "post", request, context, name: this._name } as unknown as HttpServerResponse;
	}
}
