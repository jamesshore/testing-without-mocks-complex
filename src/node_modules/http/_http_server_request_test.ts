// Copyright Titanium I.T. LLC.
import assert from "util/assert.js";
import * as testHelper from "util/test_helper.js";
import { HttpServerRequest } from "http/http_server_request.js";
import { HttpServer } from "http/http_server.js";
import { Log } from "infrastructure/log.js";
import { HttpHeaders } from "http/http_headers.js";

const PORT = 5001;

describe("HTTP Request", () => {

	describe("raw data", () => {

		it("provides URL's pathname (which ignores query)", async () => {
			await createRequestAsync({ url: "/my-url?query" }, ({ request }) => {
				assert.equal(request.urlPathname, "/my-url");
			});
		});

		it("decodes encoded URLs", async () => {
			await createRequestAsync({ url: "/a%3F%20%26%23b" }, ({ request }) => {
				assert.equal(request.urlPathname, "/a? &#b");
			});
		});

		it("provides method (and normalizes case)", async () => {
			await createRequestAsync({ method: "POst" }, ({ request }) => {
				assert.equal(request.method, "POST");
			});
		});

		it("provides headers (and normalizes case)", async () => {
			const headers = {
				myHEADER1: "myValue1",
				MYHeader2: "myValue2",
			};
			await createRequestAsync({ headers }, ({ request }) => {
				assert.deepEqual(request.headers, {
					connection: "close",
					host: `localhost:${PORT}`,
					myheader1: "myValue1",
					myheader2: "myValue2",
				});
			});
		});

		it("has immutable headers", async () => {
			const headers = { myHeader: "value" };
			await createRequestAsync({ headers }, ({ request }) => {
				delete request.headers.myHeader;
				assert.deepEqual(request.headers, {
					connection: "close",
					host: `localhost:${PORT}`,
					myheader: "value",
				});
			});
		});

		it("provides body", async () => {
			const body = ["chunk 1", "chunk 2"];
			await createRequestAsync({ body }, async ({ request }) => {
				assert.equal(await request.readBodyAsync(), "chunk 1chunk 2");
			});
		});

		it("fails fast if body is read twice", async () => {
			await createRequestAsync({}, async ({ request }) => {
				await request.readBodyAsync();
				await assert.throwsAsync(
					() => request.readBodyAsync(),
					"Can't read request body because it's already been read",
				);
			});
		});

	});


	describe("cooked content-type header", () => {

		it("checks if expected media type matches content-type header", () => {
			check("application/json", "application/json", true, "matches");
			check("application/json", "text/plain", false, "does not match");
			check("APPLICATION/json", "application/JSON", true, "should ignore case");
			check("   application/json   ", "\tapplication/json\t", true, "should ignore whitespace");
			check("application/json;charset=utf-8;foo=bar", "application/json", true, "should ignore parameters");
			check("application/json  ;  charset=utf-8", "application/json", true, "should ignore parameters with whitespace");

			function check(contentType: string, mediaType: string, expectedResult: boolean, message: string): void {
				const headers = { "content-type": contentType };
				const request = HttpServerRequest.createNull({ headers });
				assert.equal(request.hasContentType(mediaType), expectedResult, message);
			}
		});

		it("still works when content-type header doesn't exist", () => {
			const request = HttpServerRequest.createNull();
			assert.equal(request.hasContentType("application/json"), false);
		});

	});


	describe("URL-encoded forms", () => {

		it("parses body", async () => {
			const request = HttpServerRequest.createNull({ method: "POST", body: "a&a=1&a=2&b=3" });
			const form = await request.readBodyAsUrlEncodedFormAsync();
			assert.deepEqual(form, { a: [ "", "1", "2" ], b: [ "3" ]});
		});

		it("fails fast if body is read twice", async () => {
			await createRequestAsync({}, async ({ request }) => {
				await request.readBodyAsync();
				await assert.throwsAsync(
					() => request.readBodyAsUrlEncodedFormAsync(),
					"Can't read request body because it's already been read",
				);
			});
		});

	});


	describe("nulled instance", () => {

		it("provides defaults", async () => {
			const request = HttpServerRequest.createNull();

			assert.equal(request.urlPathname, "/null-request-url", "url");
			assert.equal(request.method, "GET", "method");
			assert.deepEqual(request.headers, {});
			assert.equal(await request.readBodyAsync(), "");
		});

		it("can configure URL", () => {
			const request = HttpServerRequest.createNull({ url: "/my-url" });
			assert.equal(request.urlPathname, "/my-url");
		});

		it("can configure method (and normalizes case)", () => {
			const request = HttpServerRequest.createNull({ method: "pOsT" });
			assert.equal(request.method, "POST");
		});

		it("can configure headers (and normalizes case)", () => {
			const headers = {
				myHEADER1: "myValue1",
				MYHeader2: "myValue2",
			};
			const request = HttpServerRequest.createNull({ headers });
			assert.deepEqual(request.headers, {
				myheader1: "myValue1",
				myheader2: "myValue2",
			});
		});

		it("can configure body", async () => {
			const request = HttpServerRequest.createNull({ body: "my body" });
			assert.equal(await request.readBodyAsync(), "my body");
		});

		it("fails fast when body is read twice, just like real request", async () => {
			const request = HttpServerRequest.createNull();
			await request.readBodyAsync();
			await assert.throwsAsync(
				() => request.readBodyAsync(),
				"Can't read request body because it's already been read",
			);
		});

	});
});

async function createRequestAsync(options: {
	url?: string,
	method?: string,
	headers?: HttpHeaders,
	body?: string[],
}, fnAsync: ({ request }: { request: HttpServerRequest }) => void) {
	await new Promise<void>(async (resolve, reject) => {
		try {   // exceptions aren't propagated when Promise's executor is async, so we manually catch and reject here.
			const server = HttpServer.create();
			await server.startAsync(PORT, Log.createNull(), { routeAsync });
			await testHelper.requestAsync({ port: PORT, ...options });
			await server.stopAsync();
			resolve();
		}
		catch (err) {
			reject(err);
		}

		async function routeAsync(request: HttpServerRequest): Promise<void> {
			try {
				await fnAsync({ request });
			}
			catch(err) {
				reject(err);
			}
		}
	});
}
