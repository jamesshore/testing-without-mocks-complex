// Copyright Titanium I.T. LLC.
import EventEmitter from "node:events";
import { HttpHeaders } from "http/http_headers.js";

export interface NulledHttpServerRequestResponses {
	url?: string,
	method?: string,
	headers?: HttpHeaders,
	body?: string,
}

export type FormData = Record<string, string[]>;

/** A request from a client to the HTTP server. */
export class HttpServerRequest {

	/**
	 * Factory method. Wraps a Node.js HTTP request.
	 * @param nodeRequest the Node.js HTTP request
	 * @returns {HttpServerRequest} the wrapped request
	 */
	static create(nodeRequest: NodeRequest): HttpServerRequest {
		return new HttpServerRequest(nodeRequest);
	}

	/**
	 * Factory method. Simulates an HTTP request.
	 * @param [options] details of the simulated HTTP request
	 * @param [options.url] path and optional querystring
	 * @param [options.method] method (GET, POST, etc.)
	 * @param [options.headers] headers
	 * @param [options.body] body
	 * @returns {HttpServerRequest} the simulated request
	 */
	static createNull(options?: NulledHttpServerRequestResponses): HttpServerRequest {
		return new HttpServerRequest(new StubbedNodeRequest(options));
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(private readonly _request: NodeRequest) {
	}

	/**
	 * @returns {string} URL path (excluding query)
	 */
	get urlPathname(): string {
		const url = new URL(this._request.url, "http://unused.placeholder.host");
		return decodeURIComponent(url.pathname);
	}

	/**
	 * @returns {string} method (GET, POST, etc.)
	 */
	get method(): string {
		return this._request.method;
	}

	/**
	 * @returns {object} headers
	 */
	get headers(): Record<string, string> {
		return { ...this._request.headers };
	}

	/**
	 * Determine whether the request matches a particular content-type header.
	 * @param expectedMediaType the media type to match (e.g., "application/json")
	 * @returns {boolean} true if the content-type header matches the media type
	 */
	hasContentType(expectedMediaType: string): boolean {
		const contentType = this.headers["content-type"];
		if (contentType === undefined) return false;

		const [ mediaType, ignoredParameters ] = contentType.split(";");
		return mediaType!.trim().toLowerCase() === expectedMediaType.trim().toLowerCase();
	}

	/**
	 * Read the request body. The body may only be done once.
	 * @returns {Promise<string>} the body
	 */
	async readBodyAsync(): Promise<string> {
		return await new Promise((resolve, reject) => {
			if (this._request.readableEnded) return reject(new Error("Can't read request body because it's already been read"));

			let body = "";
			this._request.on("error", reject);    // this event is not tested
			this._request.on("data", (chunk) => {
				body += chunk;
			});
			this._request.on("end", () => {
				resolve(body);
			});
		});
	}

	/**
	 * Read the request body and parse it as if it were a URL-encoded form. The body may only be read once.
	 * @returns {Promise<{}>} an object containing the form data, where the object keys are the form names
	 * and the object values are arrays containing the form values. For example, "a=1&b=2&b=3&c" will return
	 * this object: { a: [ "1" ], b: [ "2", "3" ], c: [ "" ] }
	 */
	async readBodyAsUrlEncodedFormAsync(): Promise<FormData> {
		const body = await this.readBodyAsync();
		const params = new URLSearchParams(body);

		const result: FormData = {};
		for (const key of params.keys()) {
			if (result[key] === undefined) result[key] = params.getAll(key);
		}
		return result;
	}
}


interface NodeRequest extends EventEmitter {
	url: string,
	method: string,
	headers: HttpHeaders,
	readableEnded: boolean,
}

class StubbedNodeRequest extends EventEmitter implements NodeRequest {

	public readonly url: string;
	public readonly method: string;
	public readonly headers: HttpHeaders;
	public readableEnded: boolean;
	private readonly _body: string;

	constructor({
		url = "/null-request-url",
		method = "GET",
		headers = {},
		body = "",
	}: NulledHttpServerRequestResponses = {}) {
		super();
		this.url = url;
		this.method = method.toUpperCase();
		this.headers = normalizeHeaders(headers);
		this._body = body;
		this.readableEnded = false;
	}

	override on(event: string, fn: (...args: any[]) => void): this {
		super.on(event, fn);
		if (event === "end") {
			setImmediate(() => {
				this.emit("data", this._body);
				this.emit("end");
				this.readableEnded = true;
			});
		}
		return this;
	}

}

function normalizeHeaders(headers: HttpHeaders): HttpHeaders {
	const normalizedEntries = Object.entries(headers).map(([ name, value ]) => [ name.toLowerCase(), value ]);
	return Object.fromEntries(normalizedEntries);
}