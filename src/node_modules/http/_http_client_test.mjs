// Copyright Titanium I.T. LLC.
import ensure from "util/ensure.cjs";
import assert from "util/assert.cjs";
import http from "http";
import { HttpClient } from "http/http_client.mjs";
import { ignorePromiseErrorAsync } from "util/test_helper.mjs";

const HOST = "localhost";
const PORT = 5001;

const IRRELEVANT_REQUEST = {
	host: HOST,
	port: PORT,
	method: "GET",
	path: "/irrelevant/path",
};

describe("HTTP Client", () => {

	let server;

	before(async function() {
		server = new SpyServer();
		await server.startAsync();
	});

	after(async function() {
		await server.stopAsync();
	});

	beforeEach(function() {
		server.reset();
	});


	describe("happy path", () => {

		it("performs request", async () => {
			await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
				headers: { myRequestHeader: "myRequestValue" },
				body: "my request body",
			});

			assert.deepEqual(server.lastRequest, {
				method: "POST",
				path: "/my/path",
				headers: { myrequestheader: "myRequestValue" },
				body: "my request body",
			});
		});

		it("returns response", async () => {
			server.setResponse({
				status: 999,
				headers: { myResponseHeader: "myResponseValue" },
				body: "my response",
			});

			const { response } = await requestAsync();
			assert.deepEqual(response, {
				status: 999,
				headers: { myresponseheader: "myResponseValue" },
				body: "my response",
			});
		});

		it("headers and body are optional", async () => {
			await requestAsync({
				method: "GET",
				path: "/my/new/path",
			});

			assert.deepEqual(server.lastRequest, {
				method: "GET",
				path: "/my/new/path",
				headers: {},
				body: "",
			});
		});

		it("tracks requests (which normalizes method and header names)", async () => {
			const { requests } = await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				headers: { myHeader: "myValue" },
				path: "/my/path",
				body: "my body",
			});

			assert.deepEqual(requests.data, [
				{
					host: HOST,
					port: PORT,
					method: "post",
					headers: { myheader: "myValue" },
					path: "/my/path",
					body: "my body",
				},
			]);
		});

	});


	describe("failure paths", () => {

		it("fails gracefully if connection is refused", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					host: HOST,
					port: PORT + 1,      // connection should fail because no server is established at that port
					method: "GET",
					path: "/",
				}),
				/ECONNREFUSED/,
			);
		});

		it("fails fast if body is provided with GET request", async () => {
			await assert.throwsAsync(
				() => requestAsync({
					method: "Get",
					body: "oops",
				}),
				"Don't include body with GET requests; Node won't send it",
			);
		});

	});


	describe("cancellation", () => {

		it("can cancel requests", async () => {
			server.setResponse({ hang: true });

			const { responsePromise, cancelFn } = request();

			const cancelled = cancelFn("my cancel message");

			assert.equal(cancelled, true, "cancellation should succeed");
			await assert.throwsAsync(
				() => responsePromise,
				"my cancel message",
				"request should throw exception",
			);
		});

		it("ignores additional requests to cancel", async () => {
			server.setResponse({ hang: true });

			const { responsePromise, cancelFn } = request();

			const cancelled1 = cancelFn("first cancel");
			const cancelled2 = cancelFn("second cancel");

			assert.equal(cancelled1, true, "first cancellation should succeed");
			assert.equal(cancelled2, false, "second cancellation should fail");
			await assert.throwsAsync(
				() => responsePromise,
				"first cancel",
				"request should throw exception from first cancellation",
			);
		});

		it("ignores cancellation that occurs after response has been received", async () => {
			const { cancelFn } = await requestAsync();
			const cancelled = cancelFn("my cancel");
			assert.equal(cancelled, false);
		});

		it("tracks requests that are cancelled", async () => {
			server.setResponse({ hang: true });

			const { responsePromise, cancelFn, requests } = request({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
			});

			cancelFn();
			await ignorePromiseErrorAsync(responsePromise);

			const expectedData = {
				host: HOST,
				port: PORT,
				method: "post",
				path: "/my/path",
				headers: {},
				body: "",
			};
			assert.deepEqual(requests.data, [
				expectedData,
				{ ...expectedData, cancelled: true },
			]);
		});

		it("doesn't track cancellations that occur after response", async () => {
			const { cancelFn, requests } = await requestAsync({
				host: HOST,
				port: PORT,
				method: "POST",
				path: "/my/path",
			});
			cancelFn();

			assert.deepEqual(requests.data, [{
				host: HOST,
				port: PORT,
				method: "post",
				path: "/my/path",
				headers: {},
				body: "",
			}]);
		});

	});


	describe("nulled instance", () => {

		it("doesn't talk to network", async () => {
			await requestAsync({ client: HttpClient.createNull() });

			assert.equal(server.lastRequest, null);
		});

		it("provides default response", async () => {
			const { response } = await requestAsync({ client: HttpClient.createNull() });

			assert.deepEqual(response, {
				status: 503,
				headers: { nulledhttpclient: "default header" },
				body: "Nulled HttpClient default body",
			});
		});

		it("can be configured with a different response per endpoint (and normalizes headers)", async () => {
			const client = HttpClient.createNull({
				"/endpoint/1": { status: 200, headers: { myHeader: "myValue" }, body: "endpoint 1 body" },
				"/endpoint/2": { status: 301, body: "endpoint 2 body" },
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint/1" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint/2" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader: "myValue" },
				body: "endpoint 1 body",
			}, "response1");
			assert.deepEqual(response2, {
				status: 301,
				headers: {},
				body: "endpoint 2 body",
			}, "response2");
		});

		it("treats query strings as separate endpoints", async () => {
			const client = HttpClient.createNull({
				"/endpoint?query=1": { status: 200, headers: { myHeader: "myValue" }, body: "endpoint 1 body" },
				"/endpoint?query=2": { status: 301, body: "endpoint 2 body" },
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint?query=1" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint?query=2" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader: "myValue" },
				body: "endpoint 1 body",
			}, "response1");
			assert.deepEqual(response2, {
				status: 301,
				headers: {},
				body: "endpoint 2 body",
			}, "response2");
		});

		it("provides an infinite number of responses when an endpoint has one response configured", async () => {
			const client = HttpClient.createNull({
				"/endpoint": { status: 200, body: "my body" },
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response1, {
				status: 200,
				headers: {},
				body: "my body",
			}, "response1");
			assert.deepEqual(response2, {
				status: 200,
				headers: {},
				body: "my body",
			}, "response2");
		});

		it("provides distinct responses when an endpoint has a list of responses configured", async () => {
			const client = HttpClient.createNull({
				"/endpoint": [
					{ status: 200, headers: { myHeader: "myValue" }, body: "request 1 body" },
					{ status: 404 },
					{ status: 301, body: "request 3 body" },
				],
			});

			const { response: response1 } = await requestAsync({ client, path: "/endpoint" });
			const { response: response2 } = await requestAsync({ client, path: "/endpoint" });
			const { response: response3 } = await requestAsync({ client, path: "/endpoint" });

			assert.deepEqual(response1, {
				status: 200,
				headers: { myheader: "myValue" },
				body: "request 1 body",
			}, "response1");
			assert.deepEqual(response2, {
				status: 404,
				headers: {},
				body: "",
			}, "response2");
			assert.deepEqual(response3, {
				status: 301,
				headers: {},
				body: "request 3 body",
			}, "response3");
		});

		it("throws exception when list of configured responses runs out", async () => {
			const client = HttpClient.createNull({
				"/endpoint": [{ status: 200, body: "my body" }],
			});

			await assert.doesNotThrowAsync(
				() => requestAsync({ client, path: "/endpoint" }),
				"first request should succeed"
			);

			await assert.throwsAsync(
				() => requestAsync({ client, path: "/endpoint" }),
				"No more responses configured in nulled HTTP client: /endpoint",
				"second request should fail"
			);
		});

		it("simulates hangs", async () => {
			const client = HttpClient.createNull({ "/endpoint": { hang: true } });
			const { responsePromise } = request({ client, path: "/endpoint" });

			await assert.promiseDoesNotResolveAsync(responsePromise);
		});

		it("can cancel requests", async () => {
			const client = HttpClient.createNull({ "/endpoint": { hang: true } });
			const { responsePromise, cancelFn } = request({ client, path: "/endpoint" });

			cancelFn("my error");
			await assert.throwsAsync(
				() => responsePromise,
				"my error",
			);
		});

	});

});



function request({
	client = HttpClient.create(),
	host = HOST,
	port = PORT,
	method = "GET",
	path = "/irrelevant_path",
	headers = undefined,
	body = undefined,
} = {}) {
	ensure.signature(arguments, [[ undefined, {
		client: [ undefined, HttpClient ],
		host: [ undefined, String ],
		port: [ undefined, Number ],
		method: [ undefined, String ],
		path: [ undefined, String ],
		headers: [ undefined, Object ],
		body: [ undefined, String ],
	}]]);

	const requests = client.trackRequests();

	const { responsePromise, cancelFn } = client.request({ host, port, method, path, headers, body });

	return { responsePromise, cancelFn, requests };
}

async function requestAsync(options) {
	const { responsePromise, ...results } = request(options);
	const response = await responsePromise;
	return { response, ...results };
}


class SpyServer {

	constructor() {
		this.reset();
	}

	reset() {
		this.lastRequest = null;
		this._nextResponse = {
			status: 500,
			headers: {},
			body: "SpyServer response not specified",
		};
	}

	startAsync() {
		return new Promise((resolve, reject) => {
			this._server = http.createServer();
			this._server.on("request", (request, response) => {
				let body = "";
				request.on("data", (chunk) => {
					body += chunk;
				});
				request.on("end", () => {
					const headers = { ...request.headers };
					delete headers.connection;
					delete headers["content-length"];
					delete headers.host;
					this.lastRequest = {
						method: request.method,
						path: request.url,
						headers,
						body,
					};

					if (!this._nextResponse.hang) {
						response.statusCode = this._nextResponse.status;
						Object.entries(this._nextResponse.headers).forEach(([ key, value ]) => {
							response.setHeader(key, value);
						});

						response.end(this._nextResponse.body);
					}
				});
			});

			this._server.once("listening", () => {
				resolve();
			});

			this._server.listen(PORT);
		});
	}

	stopAsync() {
		return new Promise((resolve, reject) => {
			this._server.once("close", () => {
				resolve();
			});
			this._server.close();
		});
	}

	setResponse(response) {
		this._nextResponse = response;
	}

}