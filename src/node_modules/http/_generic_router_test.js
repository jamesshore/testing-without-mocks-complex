// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const ensure = require("util/ensure");
const GenericRouter = require("./generic_router");
const HttpRequest = require("./http_request");

describe("Generic Router", () => {

	describe("happy paths", () => {

		it("converts an HTTP request into a function call and returns the result", async () => {
			const router = createRouter({
				"/": {
					getAsync() { return "get called"; },
					postAsync() { return "post called"; },
				},
			});

			assert.equal(await routeAsync(router, { method: "get", url: "/" }), "get called");
			assert.equal(await routeAsync(router, { method: "post", url: "/" }), "post called");
		});

		it("passes request to route", async () => {
			const router = createRouter({
				"/": {
					getAsync(request) { return request; }
				},
			});
			const request = HttpRequest.createNull({ method: "get", url: "/" });

			assert.equal(await router.routeAsync(request), request);
		});

		it("supports multiple paths", async () => {
			const router = createRouter({
				"/one": {
					getAsync() { return "one called"; },
				},
				"/two/is/a/deep/path": {
					getAsync() { return "two called"; },
				},
			});

			assert.equal(await routeAsync(router, { method: "get", url: "/one" }), "one called");
		});

		it("ignores query strings and fragments", async () => {
			const router = createRouter({
				"/my_url": {
					getAsync() { return "get called"; }
				},
			});

			assert.equal(
				await routeAsync(router, { method: "get", url: "/my_url?query=something#fragment" }),
				"get called"
			);
		});

	});


	describe("failure paths", () => {

		it("calls error function when path not found", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({}, errorHandler);

			const request = HttpRequest.createNull({ url: "/anything" });
			assert.deepEqual(await router.routeAsync(request), {
				status: 404,
				errorMessage: "not found",
				request,
			});
		});

		it("calls error function when method not defined", async () => {
			function errorHandler(status, errorMessage, request) {
				return { status, errorMessage, request };
			}
			const router = createRouter({
				"/": {}
			}, errorHandler);

			const request = HttpRequest.createNull({ method: "get", url: "/" });
			assert.deepEqual(await router.routeAsync(request), {
				status: 405,
				errorMessage: "method not allowed",
				request,
			});
		});

	});

});


function createRouter(routes, errorFnAsync = fallbackErrorHandler) {
	ensure.signature(arguments, [ Object, [ undefined, Function ]]);
	return GenericRouter.create(errorFnAsync, routes);
}

async function routeAsync(router, requestOptions) {
	const request = HttpRequest.createNull(requestOptions);
	return await router.routeAsync(request);
}

function fallbackErrorHandler(status, message, route) {
	throw new Error(`fallback error handler called: ${JSON.stringify({ status, message, route })}`);
}