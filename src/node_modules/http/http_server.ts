// Copyright Titanium I.T. LLC.
import * as type from "util/type.js";
import http from "node:http";
import EventEmitter from "node:events";
import { HttpServerRequest, NodeHttpServerRequest } from "http/http_server_request.js";
import { HttpServerResponse } from "http/http_server_response.js";
import { Log } from "infrastructure/log.js";
import { HttpHeader, HttpHeaders } from "http/http_headers.js";

const ROUTER_TYPE = {
	routeAsync: Function,
};

export interface Router {
	routeAsync(request: HttpServerRequest): HttpServerResponse | Promise<HttpServerResponse>,
}

/** A general-purpose HTTP server. */
export class HttpServer {

	private _started: boolean;
	private _port!: number;
	private _log!: Log;
	private _router!: Router;
	private _nodeServer: NodeServer;

	/**
	 * Factory method. Creates the server instance, but doesn't start it.
	 * @returns {HttpServer} the server
	 */
	static create(): HttpServer {
		return new HttpServer(http);
	}

	/**
	 * Factory method. Creates a 'nulled' server instance that simulates listening on a port rather than
	 * actually doing so.
	 * @returns {HttpServer} the nulled server
	 */
	static createNull(): HttpServer {
		return new HttpServer(stubbedHttp);
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(private readonly _http: NodeHttp) {
		this._started = false;
		this._nodeServer = this._http.createServer();
	}

	/**
	 * @returns {boolean} true if the server has been started
	 */
	get isStarted(): boolean {
		return this._started;
	}

	/**
	 * @returns {number | null} the port the server is listening on, or null if it hasn't been started
	 */
	get port(): number | null {
		return this.isStarted ? this._port : null;
	}

	/**
	 * Start the server.
	 * @param port the port to listen on
	 * @param log logger to use for internal server errors
	 * @param router router for handling requests
	 */
	async startAsync(port: number, log: Log, router: Router): Promise<void> {
		this.#ensureStopped("Can't start server because it's already running");

		this._port = port;
		this._log = log;
		this._router = router;

		this._started = true;   // located before promise to avoid potential race condition
		await new Promise<void>((resolve, reject) => {
			this._nodeServer.on("listening", () => this.#onStartup(resolve));
			this._nodeServer.on("error", (err) => this.#onStartupError(err, reject));
			this._nodeServer.on("request", (request, response) => this.#onRequestAsync(request, response));

			this._nodeServer.listen(this._port);
		});
	}

	/**
	 * Stop the server.
	 */
	async stopAsync(): Promise<void> {
		this.#ensureStarted("Can't stop server because it isn't running");

		await new Promise<void>((resolve, reject) => {
			this._nodeServer.on("close", resolve);
			this._nodeServer.close();
		});
		this._started = false;
	}

	/**
	 * Simulate an HTTP request.
	 * @param httpRequest the request to simulate
	 * @returns {Promise<HttpServerResponse>} the HTTP response
	 */
	async simulateRequestAsync(
		httpRequest: HttpServerRequest = HttpServerRequest.createNull()
	): Promise<HttpServerResponse> {
		this.#ensureStarted("Can't simulate request because server isn't running");

		return await this.#handleRequestAsync(httpRequest);
	}

	#onStartup(resolve: () => void): void {
		this._log.info({
			message: "server started",
			port: this._port,
		});
		resolve();
	}

	#onStartupError(err: Error, reject: (err: Error) => void): void {
		reject(new Error(`Couldn't start server due to error: ${err.message}`));
	}

	async #onRequestAsync(nodeRequest: NodeHttpServerRequest, nodeResponse: NodeResponse): Promise<void> {
		const httpRequest = HttpServerRequest.create(nodeRequest);
		const httpResponse = await this.#handleRequestAsync(httpRequest);
		sendResponse(httpResponse, nodeResponse);
	}

	async #handleRequestAsync(httpRequest: HttpServerRequest): Promise<HttpServerResponse> {
		try {
			const response = await this._router.routeAsync(httpRequest);
			const typeError = type.check(response, HttpServerResponse);
			if (typeError !== null) {
				return internalServerError(this._log, response, "request handler returned invalid response");
			}
			else {
				return response;
			}
		}
		catch (err: any) {
			return internalServerError(this._log, err, "request handler threw exception");
		}
	}

	#ensureStarted(message: string): void {
		if (!this.isStarted) throw new Error(message);
	}

	#ensureStopped(message: string): void {
		if (this.isStarted) throw new Error(message);
	}

}

function sendResponse(httpResponse: HttpServerResponse, nodeResponse: NodeResponse): void {
	nodeResponse.statusCode = httpResponse.status;
	setHeaders(nodeResponse, httpResponse.headers);
	nodeResponse.end(httpResponse.body);
}

function setHeaders(nodeResponse: NodeResponse, headers: HttpHeaders): void {
	Object.entries<HttpHeader>(headers).forEach(([ name, value ]) => {
		nodeResponse.setHeader(name, value);
	});
}

function internalServerError(log: Log, details: HttpServerResponse | any, message: string): HttpServerResponse {
	log.emergency({ message, details });
	return HttpServerResponse.createPlainTextResponse({
		status: 500,
		body: "Internal Server Error",
		debug: {
			message,
			details: details instanceof Error ? details.stack : details,
		},
	});
}

type NodeResponse = http.ServerResponse;


/** Embedded Stub **/

interface NodeHttp {
	createServer(): NodeServer,
}

interface NodeServer extends EventEmitter {
	listen(port: number): void,
	close(): void,
}

const stubbedHttp = {
	createServer() {
		return new StubbedNodeServer();
	}
};

class StubbedNodeServer extends EventEmitter {
	listen() {
		setImmediate(() => this.emit("listening"));
	}
	close() {
		setImmediate(() => this.emit("close"));
	}
}