// Copyright Titanium I.T. LLC.
import http from "node:http";
import EventEmitter from "node:events";
import { OutputListener, OutputTracker } from "util/output_listener.js";
import { ConfigurableResponses } from "util/configurable_responses.js";
import { HttpHeaders } from "http/http_headers.js";

const DEFAULT_NULLED_RESPONSE: NulledHttpClientResponse = {
	status: 503,
	headers: { NulledHttpClient: "default header" },
	body: "Nulled HttpClient default body",
	hang: false,
};

export interface HttpClientRequestParameters {
	host: string,
	port: number,
	method: string,
	path: string,
	headers?: HttpHeaders | undefined,
	body?: string | undefined,
}

export interface HttpClientResponse {
	status: number,
	headers: HttpHeaders,
	body: string,
}

export type NulledHttpClientResponses = Record<string, NulledHttpClientResponse | NulledHttpClientResponse[]>;

export interface NulledHttpClientResponse {
	status?: number,
	headers?: HttpHeaders,
	body?: string,
	hang?: boolean,
}

export interface HttpClientOutput extends HttpClientRequestParameters {
	cancelled?: boolean,
}

/** A general-purpose HTTP client. */
export class HttpClient {

	private readonly _listener: OutputListener<HttpClientOutput>;

	/**
	 * Factory method. Creates the client.
	 * @returns {HttpClient} the client
	 */
	static create(): HttpClient {
		return new HttpClient(http);
	}

	/**
	 * Factory method. Creates a 'nulled' client that simulates HTTP requests rather than making real requests.
	 * @param [responses] An object that contains the simulated responses each endpoint should return. Each
	 * endpoint gets a property. The property name contains the path (e.g., '/') and the property value
	 * contains the simulated response. If a response isn't provided, a default 501 (not implemented) or
	 * 503 (service unavailable) response is returned.
	 * @param [responses.status] the status code to return
	 * @param [responses.headers] the headers to return
	 * @param [responses.body] the body to return
	 * @param [responses.hang] if true, the request never returns
	 * @returns {HttpClient} the nulled client
	 */
	static createNull(responses: NulledHttpClientResponses = {}): HttpClient {
		return new HttpClient(new StubbedHttp(responses));
	}

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(private readonly _http: NodeHttp) {
		this._listener = new OutputListener();
	}

	/**
	 * Track the HTTP requests that are made.
	 * @returns {OutputTracker} the request tracker
	 */
	trackRequests(): OutputTracker<HttpClientOutput> {
		return this._listener.trackOutput();
	}

	/**
	 * Make the HTTP request. Returns a promise for the response and a function for cancelling the request.
	 * The response is an object containing { status, headers, body }.
	 * @param host the host to call
	 * @param port the port to use
	 * @param method the request method
	 * @param path the request path (URL)
	 * @param [headers] the request headers
	 * @param [body] the request body
	 * @returns {{responsePromise: Promise, cancelFn: () => void}} the response promise and cancellation function	*/
	request({
		host,
		port,
		method,
		path,
		headers = {},
		body = ""
	}: HttpClientRequestParameters): {
		responsePromise: Promise<HttpClientResponse>,
		cancelFn: CancelFn,
	} {
		const requestOptions = {
			host,
			port,
			method: method.toLowerCase(),
			path,
			headers: normalizeHeaders(headers),
			body
		};
		if (requestOptions.method === "get" && requestOptions.body !== "") {
			throw new Error("Don't include body with GET requests; Node won't send it");
		}

		const requestStatus: RequestStatus = { inProgress: true };

		const request = this.#sendRequest(requestOptions);
		const cancelFn = this.#createCancelFn(request, requestStatus, requestOptions);

		const responsePromise = new Promise<HttpClientResponse>((resolve, reject) => {
			this.#handleResponse(request, requestStatus, resolve);
			this.#handleError(request, reject);
		});

		return { responsePromise, cancelFn };
	}

	#sendRequest(requestOptions: HttpClientRequestParameters): NodeHttpRequest {
		const { body, ...httpOptions } = requestOptions;

		const request = this._http.request(httpOptions);
		request.end(body);
		this._listener.emit(requestOptions);
		return request;
	}

	#createCancelFn(
		request: NodeHttpRequest,
		requestStatus: RequestStatus,
		requestOptions: HttpClientRequestParameters,
	): CancelFn {
		return (message?: string) => {
			if (!requestStatus.inProgress) return false;

			request.destroy(new Error(message));
			this._listener.emit({ ...requestOptions, cancelled: true });
			requestStatus.inProgress = false;
			return true;
		};
	}

	#handleResponse(
		request: NodeHttpRequest,
		requestStatus: RequestStatus,
		resolve: (value: HttpClientResponse) => void,
	): void {
		request.once("response", (response) => {
			const headers = { ...response.headers };

			let body = "";
			response.on("data", (chunk: Buffer) => {
				body += chunk;
			});
			response.on("end", () => {
				requestStatus.inProgress = false;
				resolve({
					status: response.statusCode,
					headers,
					body,
				});
			});

		});
	}

	#handleError(request: NodeHttpRequest, reject: (error: Error) => void) {
		request.once("error", reject);
	}

}

function normalizeHeaders(headers: HttpHeaders): HttpHeaders {
	const normalized = Object.entries(headers).map(([ key, value ]) => [ key.toLowerCase(), value ]);
	return Object.fromEntries(normalized);
}

interface RequestStatus {
	inProgress: boolean,
}

type CancelFn = (message?: string) => boolean;



interface NodeHttpRequest extends EventEmitter {
	end: (body?: string) => void,
	destroy: (error: Error) => void,
}


interface NodeHttpResponse {
	get statusCode(): number,
	get headers(): HttpHeaders,
}

interface NodeHttp {
	request: ({ path }: { path: string }) => NodeHttpRequest,
}

class StubbedHttp implements NodeHttp {

	private readonly _responses: Record<string, ConfigurableResponses<NulledHttpClientResponse>>;

	constructor(responses: NulledHttpClientResponses = {}) {
		this._responses = ConfigurableResponses.mapObject(responses, "nulled HTTP client");
	}

	request({ path }: { path: string }): NodeHttpRequest {
		return new StubbedRequest(path, this._responses[path]);
	}

}

class StubbedRequest extends EventEmitter implements NodeHttpRequest {

	private readonly _endpointResponses: ConfigurableResponses<NulledHttpClientResponse>;

	constructor(
		path: string,
		endpointResponses: ConfigurableResponses<NulledHttpClientResponse> = ConfigurableResponses.create(DEFAULT_NULLED_RESPONSE),
	) {
		super();

		this._endpointResponses = endpointResponses;
	}

	end(): void {
		const response = this._endpointResponses.next();
		setImmediate(() => {
			this.emit("response", new StubbedResponse(response));
		});
	}

	destroy(error: Error): void {
		setImmediate(() => {
			this.emit("error", error);
		});
	}

}

class StubbedResponse extends EventEmitter implements NodeHttpResponse {

	private readonly _status: number;
	private readonly _headers: HttpHeaders;

	constructor({
		status = 501,
		headers = {},
		body = "",
		hang = false
	}: NulledHttpClientResponse) {
		super();

		this._status = status;
		this._headers = normalizeHeaders(headers);

		setImmediate(() => {
			this.emit("data", body);
			if (!hang) this.emit("end");
		});
	}

	get statusCode(): number {
		return this._status;
	}

	get headers(): HttpHeaders {
		return this._headers;
	}

}