// Copyright Titanium I.T. LLC.
import assert from "util/assert.js";
import { HttpServer } from "http/http_server.js";
import { requestAsync } from "util/test_helper.js";
import { HttpServerRequest } from "http/http_server_request.js";
import { HttpServerResponse } from "http/http_server_response.js";
import { Log, LogData } from "infrastructure/log.js";
import { OutputTracker } from "util/output_listener.js";

const PORT = 5001;

describe("HTTP Server", () => {

	describe("starting and stopping", () => {

		it("can start and stop multiple times", async () => {
			const { server } = createServer();
			await startAndStopAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAndStopAsync({ server })
			);
		});

		it("logs server startup", async () => {
			await startAndStopAsync({}, ({ logOutput }) => {
				assert.deepEqual(logOutput.data, [{
					alert: "info",
					message: "server started",
					port: PORT,
				}]);
			});
		});

		it("says if the server is started", async () => {
			const { server } = createServer();

			assert.equal(server.isStarted, false, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.isStarted, true, "after server started");
			});
			assert.equal(server.isStarted, false, "after server stopped");
		});

		it("says which port the server is on", async () => {
			const { server } = createServer();

			assert.equal(server.port, null, "before server started");
			await startAndStopAsync({ server }, () => {
				assert.equal(server.port, PORT, "after server started");
			});
			assert.equal(server.port, null, "after server stopped");
		});

		it("fails gracefully if server has startup error", async () => {
			const { server: server1 } = createServer();
			const { server: server2 } = createServer();

			await startAndStopAsync({ server: server1 }, async () => {
				await assert.throwsAsync(
					() => startAsync({ server: server2 }),     // fails because another server is already running
					/^Couldn't start server due to error:.*?EADDRINUSE/,
				);
			});
		});

		it("fails fast if server is started twice", async () => {
			await startAndStopAsync({}, async ({ server }) => {
				await assert.throwsAsync(
					() => startAsync({ server }),
					"Can't start server because it's already running",
				);
			});
		});

		it("fails fast if server is stopped when it isn't running", async () => {
			const { server } = createServer();
			await assert.throwsAsync(
				() => stopAsync({ server }),
				"Can't stop server because it isn't running",
			);
		});

	});


	describe("requests and responses", () => {

		it("runs a routing function when a request is received, then serves the result", async () => {
			const servedResponse = {
				status: 777,
				headers: {
					header1: "value1",
					header2: "value2",
				},
				body: "my body",
			};

			function routeAsync() { return HttpServerResponse.create(servedResponse); }

			const { response } = await getAsync({ routeAsync });
			assert.deepEqual(response, servedResponse);
		});

		it("provides request object to router", async () => {
			let actualRequest;
			function routeAsync(request: HttpServerRequest) {
				actualRequest = request;
			}

			await getAsync({ routeAsync });
			assert.instanceOf(actualRequest, HttpServerRequest);
		});

		it("fails gracefully when router throws exception", async () => {
			function routeAsync() { throw new Error("routeAsync error"); }

			const { response, logOutput } = await getAsync({ routeAsync });

			assert.deepEqual(logOutput.data, [{
				alert: Log.EMERGENCY,
				message: "request handler threw exception",
				details: "Error: routeAsync error",
			}], "should log error");

			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			}, "should serve sanitized error");
		});

		it("fails gracefully when router returns invalid response", async () => {
			function routeAsync() { return "my invalid response"; }

			const { response, logOutput } = await getAsync({ routeAsync });

			assert.deepEqual(logOutput.data, [{
				alert: Log.EMERGENCY,
				message: "request handler returned invalid response",
				details: "my invalid response",
			}], "should log error");

			assert.deepEqual(response, {
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
			}, "should serve sanitized error");
		});

	});


	describe("request simulation", () => {

		it("runs router and returns response that would have been served", async () => {
			const simulatedRequest = HttpServerRequest.createNull();

			const routerResponse = HttpServerResponse.create({
				status: 777,
				headers: { myheader: "myvalue" },
				body: "my body",
			});

			let routedRequest;
			function routeAsync(request: HttpServerRequest) {
				routedRequest = request;
				return routerResponse;
			}

			const { response: receivedResponse } = await simulateRequestAsync({ request: simulatedRequest, routeAsync });

			assert.equal(routedRequest, simulatedRequest, "request");
			assert.deepEqual(receivedResponse, routerResponse, "response");
		});

		it("includes debug info in response when router throws exception", async () => {
			const expectedError = new Error("routeAsync error");
			function routeAsync() { throw expectedError; }

			const { response } = await simulateRequestAsync({ routeAsync });
			assert.deepEqual(response, HttpServerResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler threw exception",
					details: expectedError.stack,
				},
			}));
		});

		it("includes debug info in response when handler returns invalid response", async () => {
			function routeAsync() { return "my invalid response"; }

			const { response } = await simulateRequestAsync({ routeAsync });
			assert.deepEqual(response, HttpServerResponse.createPlainTextResponse({
				status: 500,
				headers: { "content-type": "text/plain; charset=utf-8" },
				body: "Internal Server Error",
				debug: {
					message: "request handler returned invalid response",
					details: "my invalid response",
				},
			}));
		});

		it("simulating requests fails fast when server isn't running", async () => {
			const server = HttpServer.createNull();
			await assert.throwsAsync(
				() => server.simulateRequestAsync(),
				"Can't simulate request because server isn't running",
			);
		});

	});


	describe("nullability", () => {

		it("doesn't actually start or stop the server", async () => {
			const server = HttpServer.createNull();
			const server2 = HttpServer.createNull();

			await startAsync({ server });
			await assert.doesNotThrowAsync(
				() => startAsync({ server: server2 }),     // would fail if server is real because address is already in use
			);
			await stopAsync({ server });
		});

	});

});


type RouterFn = (request: HttpServerRequest) => any;
type LogOutput = OutputTracker<LogData>;

async function getAsync({
	routeAsync = () => HttpServerResponse.createForTestingOnly(),
}: {
	routeAsync?: RouterFn,
} = {}): Promise<{
	response: HttpServerResponse,
	logOutput: LogOutput,
}> {
	return await startAndStopAsync({ routeAsync }, async ({ logOutput }) => {
		logOutput.clear();
		return {
			response: await requestAsync({ port: PORT }),
			logOutput,
		};
	});
}

async function simulateRequestAsync({
	request = HttpServerRequest.createNull(),
	routeAsync = () => HttpServerResponse.createForTestingOnly(),
}: {
	request?: HttpServerRequest,
	routeAsync?: RouterFn,
} = {}): Promise<{
	response: HttpServerResponse,
}> {
	const server = HttpServer.createNull();
	await startAsync({ server, routeAsync });
	const response = await server.simulateRequestAsync(request);

	return { response };
}

type StartAndStopFn = (args: { logOutput: LogOutput, server: HttpServer }) => any;

async function startAndStopAsync(
	options: StartAsyncOptions,
	fnAsync: StartAndStopFn = () => {},
) {
	const { server, logOutput } = await startAsync(options);
	try {
		return await fnAsync({ logOutput, server });
	}
	finally {
		await stopAsync({ server });
	}
}

interface StartAsyncOptions {
	server?: HttpServer,
	routeAsync?: RouterFn,
}

async function startAsync({
	server = createServer().server,
	routeAsync = () => HttpServerResponse.createForTestingOnly(),
}: StartAsyncOptions = {}): Promise<{
	server: HttpServer,
	logOutput: LogOutput,
}> {
	const log = Log.createNull();
	const logOutput = log.trackOutput();
	await server.startAsync(PORT, log, { routeAsync });

	return { server, logOutput };
}

async function stopAsync({ server }: { server: HttpServer }): Promise<void> {
	await server.stopAsync();
}

function createServer(): { server: HttpServer } {
	const server = HttpServer.create();
	return { server };
}