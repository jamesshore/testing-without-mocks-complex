// Copyright Titanium I.T. LLC.
import assert from "util/assert.js";
import { Clock } from "infrastructure/clock.js";

const UNRESOLVABLE_PROMISE = new Promise<void>(() => {});

describe("Clock", () => {


	describe("waiting", () => {

		it("waits N milliseconds", async () => {
			const clock = Clock.create();

			const start = clock.now();
			await clock.waitAsync(10);
			const elapsedTime = clock.now() - start;
			assert.isAtLeast(elapsedTime, 9);
		});

	});


	describe("current time", () => {

			it("provides current timestamp", () => {
				const clock = Clock.create();

				let expected = Date.now();
				const actual = clock.now();
				if (actual !== expected) expected = Date.now();
				assert.equal(actual, expected);
			});

			it("outputs current time using computer's language and time zone", () => {
				const format: Intl.DateTimeFormatOptions = {
					dateStyle: "medium",
					timeStyle: "short",
					timeZone: "local",
				};
				const formatCopy = { ...format };
				const jsFormat: Intl.DateTimeFormatOptions = {
					dateStyle: "medium",
					timeStyle: "short",
				};

				checkToFormattedString(format, jsFormat, "local", undefined);
				assert.deepEqual(format, formatCopy, "should not modify original format object");
			});

			it("outputs current time using configured time zone and locale", () => {
				const format: Intl.DateTimeFormatOptions = {
					timeZone: "Europe/Paris",
					dateStyle: "medium",
					timeStyle: "short",
				};
				const locale = "fr";
				checkToFormattedString(format, format, locale, locale);
			});

			it("fails fast if time zone isn't specified", () => {
				assert.throws(
					() => Clock.create().toFormattedString({}, "en-US"),
					"Must specify options.timeZone (use 'local' for computer's time zone)",
				);
			});

			it("fails fast if locale isn't specified", () => {
				assert.throws(
					() => Clock.create().toFormattedString({ timeZone: "UTC" }),
					"Must specify locale (use 'local' for computer's default locale)",
				);
			});

			function checkToFormattedString(
				ourFormat: Intl.DateTimeFormatOptions,
				jsFormat: Intl.DateTimeFormatOptions,
				ourLocale: string,
				jsLocale: string | undefined,
			) {
				const clock = Clock.create();
				let expected = new Date().toLocaleString(jsLocale, jsFormat);
				const actual = clock.toFormattedString(ourFormat, ourLocale);
				if (expected !== actual) expected = new Date().toLocaleString(jsLocale, jsFormat);

				assert.equal(actual, expected);
			}

		},
	);


	describe("timeouts", () => {

		it("resolves if promise resolves before timeout", async () => {
			const { resultPromise, msElapsed, timeoutRan } = await timeoutAsync({
				promise: Promise.resolve("my promise")
			});

			assert.equal(msElapsed, 0, "should resolve immediately");
			assert.equal(timeoutRan, false, "should not run timeout function");
			assert.equal(await resultPromise, "my promise", "should return resolved promise");
		});

		it("rejects if promise rejects before timeout", async () => {
			const { resultPromise, msElapsed, timeoutRan } = await timeoutAsync({
				promise: Promise.reject(new Error("my error"))
			});

			assert.equal(msElapsed, 0, "should resolve immediately");
			assert.equal(timeoutRan, false, "should not run timeout function");
			await assert.throwsAsync(() => resultPromise, "my error", "should return rejected promise");

		});

		it("resolves via timeout function if promise times out", async () => {
			const { resultPromise, msElapsed, timeoutRan } = await timeoutAsync({
				timeoutInMs: 10000,
				promise: UNRESOLVABLE_PROMISE,
				timeoutResult: Promise.resolve("timeout result"),
			});

			assert.equal(msElapsed, 10000, "should wait for timeout");
			assert.equal(timeoutRan, true, "should run timeout function");
			assert.equal(await resultPromise, "timeout result", "should return result of timeout function");
		});

		it("rejects via timeout function if promise times out and timeout rejects", async () => {
			const { resultPromise, msElapsed, timeoutRan } = await timeoutAsync({
				timeoutInMs: 10000,
				promise: UNRESOLVABLE_PROMISE,
				timeoutResult: Promise.reject(new Error("my error")),
			});

			assert.equal(msElapsed, 10000, "should wait for timeout");
			assert.equal(timeoutRan, true, "should run timeout function");
			await assert.throwsAsync(() => resultPromise, "my error", "should reject because timeout function rejected");
		});

		it("ignores promise resolution after timeout", async () => {
			const clock = Clock.createNull();
			const { resultPromise } = await timeoutAsync({
				clock,
				timeoutInMs: 10000,
				promise: new Promise(async (resolve) => {
					await clock.waitAsync(20000);
					resolve("this result should be ignored");
				}),
				timeoutResult: Promise.resolve("timeout result"),
			});

			assert.equal(await resultPromise, "timeout result");
		});

		it("ignores promise rejection after timeout", async () => {
			const clock = Clock.createNull();
			const { resultPromise } = await timeoutAsync({
				clock,
				timeoutInMs: 10000,
				promise: new Promise(async (resolve, reject) => {
					await clock.waitAsync(20000);
					reject(new Error("this error should be ignored"));
				}),
				timeoutResult: Promise.resolve("timeout result"),
			});

			assert.equal(await resultPromise, "timeout result");
		});

	});


	describe("nullability", () => {

		it("defaults 'now' to zero", () => {
			const clock = Clock.createNull();
			assert.equal(clock.now(), 0);
		});

		it("allows 'now' to be configured", () => {
			const clock = Clock.createNull({ now: 42 });
			assert.equal(clock.now(), 42);
		});

		it("renders to formatted string", () => {
			const clock = Clock.createNull({ now: 0 });

			const format: Intl.DateTimeFormatOptions = {
				timeZone: "Europe/Paris",
				dateStyle: "medium",
				timeStyle: "short",
			};
			assert.equal(clock.toFormattedString(format, "fr"), "1 janv. 1970, 01:00");
		});

		it("defaults time zone and locale to little-used values to prevent false successes", () => {
			const clock = Clock.createNull({ now: 0 });
			const format: Intl.DateTimeFormatOptions = { dateStyle: "medium", timeStyle: "long", timeZone: "local" };
			const formatCopy = { ...format };

			assert.equal(clock.toFormattedString(format, "local"), "1970 J-guer 1 10:00:00 GMT+10");
			assert.deepEqual(format, formatCopy, "should not modify original format object");
		});

		it("allows local time zone and locale to be configured", () => {
			const clock = Clock.createNull({ now: 0, timeZone: "America/New_York", locale: "uk" });
			const format: Intl.DateTimeFormatOptions = { dateStyle: "medium", timeStyle: "long", timeZone: "local" };
			assert.equal(clock.toFormattedString(format, "local"), "31 груд. 1969 р., 19:00:00 GMT-5");
		});

		it("can advance the clock", async () => {
			const clock = Clock.createNull();
			await clock.advanceNulledClockAsync(10);
			assert.equal(clock.now(), 10);
		});

		it("can advance the clock until all timers expire", async () => {
			const clock = Clock.createNull();
			clock.waitAsync(999);
			await clock.advanceNulledClockUntilTimersExpireAsync();
			assert.equal(clock.now(), 999);
		});

		it("fails fast when attempting to advance the system clock", async () => {
			const clock = Clock.create();
			await assert.throwsAsync(
				() => clock.advanceNulledClockAsync(10),
				"Can't advance the clock because it isn't a nulled clock"
			);
			await assert.throwsAsync(
				() => clock.advanceNulledClockUntilTimersExpireAsync(),
				"Can't advance the clock because it isn't a nulled clock"
			);
		});

		it("can wait", async () => {
			const clock = Clock.createNull();
			let wait: string | number = "waiting";

			clock.waitAsync(10).then(() => {
				wait = clock.now();
			});
			assert.equal(wait, "waiting");
			await clock.advanceNulledClockAsync(20);
			assert.equal(wait, 10);
		});

		it("can timeout", async () => {
			const clock = Clock.createNull();
			await clock.timeoutAsync(10, Promise.resolve(), () => {});
		});

	});

});

async function timeoutAsync({
	clock = Clock.createNull({ now: 0 }),
	timeoutInMs = 42,
	promise = Promise.resolve("irrelevant promise"),
	timeoutResult = Promise.resolve("irrelevant timeout result"),
}: {
	clock?: Clock,
	timeoutInMs?: number,
	promise?: Promise<any>,
	timeoutResult?: Promise<any>,
} = {}) {
	let timeoutRan = false;
	const timeoutFn = () => {
		timeoutRan = true;
		return timeoutResult;
	};

	const resultPromise = clock.timeoutAsync(timeoutInMs, promise, timeoutFn);

	// prevent 'unhandled rejection' errors
	resultPromise.catch(() => {});
	timeoutResult.catch(() => {});

	await clock.advanceNulledClockUntilTimersExpireAsync();

	return { resultPromise, timeoutRan, msElapsed: clock.now() };
}
