// Copyright Titanium I.T. LLC.
import { OutputListener, OutputTracker } from "util/output_listener.js";
import { CommandLine } from "infrastructure/command_line.js";
import { Clock } from "infrastructure/clock.js";

export type LogOutput = Record<string, any>;

/**
 * Logger. Writes structured logs as JSON to stdout. Provides the ability to set default values which
 * are included in every log output.
 */
export class Log {

  private _listener: OutputListener<LogOutput>;

	/**
	 * Factory method. Creates a logger.
	 * @returns {Log} the logger
	 */
	static create(): Log {
		return new Log(CommandLine.create(), Clock.create());
	}

	/**
	 * Factory method. Creates a logger that doesn't write to stdout.
	 * @returns {Log} the nulled logger
	 */
	static createNull(): Log {
		return new Log(CommandLine.createNull(), Clock.createNull());
	}

	/**
	 * @returns {string} 'debug' alert level
	 */
	static get DEBUG(): "debug" { return "debug"; }

	/**
	 * @returns {string} 'info' alert level
	 */
	static get INFO(): "info" { return "info"; }

	/**
	 * @returns {string} 'monitor' alert level
	 */
	static get MONITOR(): "monitor" { return "monitor"; }

	/**
	 * @returns {string} 'action' alert level
	 */
	static get ACTION(): "action" { return "action"; }

	/**
	 * @returns {string} 'emergency' alert level
	 */
	static get EMERGENCY(): "emergency" { return "emergency"; }

	/** Only for use by tests. (Use a factory method instead.) */
	constructor(
		private readonly _commandLine: CommandLine,
		private readonly _clock: Clock,
		private readonly _defaults: LogOutput = {},
	) {
		this._listener = new OutputListener();
	}

	/**
	 * @returns {object} the logger's default values (properties that are written with every log)
	 */
	get defaults() {
		return this._defaults;
	}

	/**
	 * Write a log entry with the 'debug' alert level.
	 * @param data the data to write.
	 */
	debug(data: LogOutput): void { this.#log(Log.DEBUG, data); }

	/**
	 * Write a log entry with the 'info' alert level.
	 * @param data the data to write.
	 */
	info(data: LogOutput): void { this.#log(Log.INFO, data); }

	/**
	 * Write a log entry with the 'monitor' alert level.
	 * @param data the data to write.
	 */
	monitor(data: LogOutput): void { this.#log(Log.MONITOR, data); }

	/**
	 * Write a log entry with the 'action' alert level.
	 * @param data the data to write.
	 */
	action(data: LogOutput): void { this.#log(Log.ACTION, data); }

	/**
	 * Write a log entry with the 'emergency' alert level.
	 * @param data the data to write.
	 */
	emergency(data: LogOutput): void { this.#log(Log.EMERGENCY, data); }

	/**
	 * Create a new logger, based on this one, which has additional default parameters. Existing defaults are
	 * carried over. New defaults override existing defaults with the same name. Output tracking is shared by
	 * both logs.
	 * @param defaults default parameters for the new logger
	 * @returns {Log} the new logger
	 */
	bind(defaults: LogOutput): Log {
		const newLog = new Log(this._commandLine, this._clock, { ...this._defaults, ...defaults });
		newLog._listener = this._listener;
		return newLog;
	}

	/**
	 * Track log output.
	 * @returns {OutputTracker} the output tracker
	 */
	trackOutput(): OutputTracker<LogOutput> {
		return this._listener.trackOutput();
	}

	#log(alert: "debug" | "info" | "monitor" | "action" | "emergency", data: LogOutput): void {
		data = { alert, ...this._defaults, ...data };
		const { dataToLog, dataToTrack } = normalizeErrors(data);

		this._commandLine.writeStdout(`${(currentFormattedTime(this._clock))} ${JSON.stringify(dataToLog)}\n`);
		this._listener.emit(dataToTrack);
	}

}

function normalizeErrors(data: LogOutput): { dataToLog: LogOutput, dataToTrack: LogOutput } {
	const dataToLog: LogOutput = {};
	const dataToTrack: LogOutput = {};

	Object.entries(data).forEach(([ name, value ]) => {
		let logValue: string | undefined = value;
		let trackValue = value;
		if (value instanceof Error) {
			logValue = value.stack;
			trackValue = `${value.name}: ${value.message}`;
		}
		dataToLog[name] = logValue;
		dataToTrack[name] = trackValue;
	});

	return { dataToLog, dataToTrack };
}

function currentFormattedTime(clock: Clock) {
	const options: Intl.DateTimeFormatOptions = {
		dateStyle: "medium",
		timeStyle: "long",
		timeZone: "UTC",
		hourCycle: "h23",
	};
	return clock.toFormattedString(options, "en-US");
}
